# Зад. 53 2022-SE-02 Дефинирана е система за бекъпване на сървъри, която държи направените архиви в главна директория (която ще наричаме fubar ), в която има четири под-директории за различни класове бекъпи:
# • 0 – съдържа годишни бекъпи
# • 1 – съдържа месечни бекъпи
# • 2 – съдържа седмични бекъпи
# • 3 – съдържа дневни бекъпи
# Всяка директория съдържа архивни файлове с имена във формат hostname-area-YYYYMMDD.tar.xz, където:
# • hostname е името на някаква машина, която е бекъпвана;
# • area е типът бекъп за съответната машина;
# • YYYYMMDD е датата, на която е направен бекъпа;
# • никое от горните полета не може да съдържа тире или точка;
# • някои от файловете могат да са symlink-ове.
# Примерни имена на файлове:
# astero-etc-20220323.tar.xz stratios-etc-20220428.tar.xz nestor-db-20220404.tar.xz
# gila-srv-20220405.tar.xz catalyst-var-20220406.tar.xz drake-home-20220404.tar.xz
# dominix-var-20220404.tar.xz
# Комбинацията от hostname и area дефинира уникален обект за бекъпване. Всички архивни файлове са пълноценни бекъпи на даден обект и са достатъчни за неговото възстановяване при нужда 
#(заб. извън обхвата на задачата).
# Ако даден файл е symlink, то той може да е валиден или счупен. Symlink-овете са създадени за удобство и не ги считаме за пълноценни бекъпи.
# Политиката ни за бекъп казва, че за да имаме валиден бекъп на даден обект, за него трябва да имаме минимум 1 годишен, 2 месечни, 3 седмични и 4 дневни пълноценни бекъпа.
# Важност:
# • обектите са равни по важност помежду си;
# • важността на класовете бекъпи е във възходящ ред по горния списък, т.е. при равни други условия дневните бекъпи са по-ценни от седмичните и т.н.;
# • в рамките на един клас бекъпи по-новите бекъпи са по-важни от по-старите.
# Напишете shell скрипт, който приема два два задължителни позиционни аргумента – име на директория и число в интервала [1, 99]. Примерно извикване: ./foo.sh ./bar/ 30 където:
# • директорията представлява главна директория (fubar ) на описаната система за бекпъване;
# • числото дефинира колко процента е максималното допустимо използвано място на файловата система, в която се намира подадената директория.
# За удобство приемаме, че директорията fubar и всички обекти в нея се намират в една и съща файлова система.
# Упътване: Командата df извикана с аргумент име на файл/директория връща информация за файловата система, в която той се намира. Пример:
# $ df ./README.md
# Filesystem 1K-blocks Used Available Use% Mounted on
# /dev/mapper/o7-hm 100663296 61735732 37288764 63% /home
# Скриптът трябва да изтрива минимален брой пълноценни архивни файлове така, че:
# • всеки обект да има валиден бекъп;
# • обръща внимание на описаните по-горе важности;
# • процентите използвано място върху файловата система да е не повече от подаденият параметър 
#(a ако това е невъзможно, скриптът да освободи колкото може повече място, без да нарушава валидностите на бекъпите на обектите);
# • не е допустимо след работата на скрипта да останат счупени symlink–ове.

#!/bin/bash

if [[ $# -ne 2 ]]; then
	echo "wrong input"
	exit 1
fi

if [[ ! -d "${1}" ]]; then
	echo "not a dir"
	exit 2
fi

if ! [[ "${2}" =~ ^[0-9]+$ ]]; then
	echo "not a num"
	exit 3
fi

if [[ ${2} -lt 1 ]] || [[ ${2} -gt 99  ]]; then
	echo "not a num between 1 and 99"
	exit 4
fi

dir=$1
num=$2

for link in $(find -L "${dir}" -type l); do
	rm -r ${link}
done

#find -L "${dir}" -type l -print0 | xargs -0 rm -r

for file in $(find "${dir}" -type f -regextype egrep -regex "^[a-zA-Z0-9]+\-[a-zA-Z0-9]+\-[0-9]{8}\.tar\.xz$"); do
	df_percent=$(df "${file}" | tail -n +2 | awk '{print $5}' | tr -d '%')
	if [[ $df_percent -gt $num ]]; then
			rm ${file}
	fi
	
	count_yearly=$(find "${dir}/0" -type f -name "${file}" | wc -l)
	count_monthly=$(find "${dir}/1" -type f -name "${file}" | wc -l)
	count_weekly=$(find "${dir}/2" -type f -name "${file}" | wc -l)
	count_daily=$(find "${dir}/3" -type f -name "${file}" | wc -l)

	if [[ $count_yearly -eq 1 || $count_yearly -gt 1 ]] && [[ $count_monthly -eq 2 || $count_montly -gt 2 ]]
	&& [[ $count_weekly -eq 3 || $count_weekly -gt 3 ]] && [[ $count_daily -eq 4 || $count_daily -gt 4 ]];
		echo "this ${file} is valid backup"
	else
		rm "${file}"
	fi
done